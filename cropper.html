<script src="https://unpkg.com/vue@next"></script>
<script src="https://unpkg.com/vue-advanced-cropper@^2.0.0/dist/index.umd.js" />
<link rel="stylesheet" href="https://unpkg.com/vue-advanced-cropper@^2.0.0/dist/style.css" />


<script src="https://unpkg.com/vue@next"></script>
<script src="https://unpkg.com/vue-advanced-cropper@^2.0.0"></script>
<link rel="stylesheet" href="https://unpkg.com/vue-advanced-cropper@^2.0.0/dist/style.css" />

<div id="app">
  <cropper
    :src="image.src"
    @change="change"
    ref="cropper"
  ></cropper>
  <button @click="crop">
		Crop
	</button>
  <div class="button-wrapper">
    <input type="file" ref="file" @change="loadPDF($event)" accept="application/pdf">
    <button class="button" @click="$refs.file.click()">
      Load PDF file
    </button>
  </div>
  <div class="input-wrapper">
    <input type="number" @change="loadPreviewOfPdf()" v-model.number="pdf.page" min="0" :max="pdf.max_page"/>
    <span>Page {{pdf.page + 1}} of {{ pdf.max_page + 1 }}</span>
  </div>
</div>

<script>
  // https://gist.github.com/davalapar/d0a5ba7cce4bc599f54800da22926da2
  function downloadFile(data, filename, mime) {
  // It is necessary to create a new blob object with mime-type explicitly set
  // otherwise only Chrome works like it should
  const blob = new Blob([data], {type: mime || 'application/octet-stream'});
  if (typeof window.navigator.msSaveBlob !== 'undefined') {
    // IE doesn't allow using a blob object directly as link href.
    // Workaround for "HTML7007: One or more blob URLs were
    // revoked by closing the blob for which they were created.
    // These URLs will no longer resolve as the data backing
    // the URL has been freed."
    window.navigator.msSaveBlob(blob, filename);
    return;
  }
  // Other browsers
  // Create a link pointing to the ObjectURL containing the blob
  const blobURL = window.URL.createObjectURL(blob);
  const tempLink = document.createElement('a');
  tempLink.style.display = 'none';
  tempLink.href = blobURL;
  tempLink.setAttribute('download', filename);
  // Safari thinks _blank anchor are pop ups. We only want to set _blank
  // target if the browser does not support the HTML5 download attribute.
  // This allows you to download files in desktop safari if pop up blocking
  // is enabled.
  if (typeof tempLink.download === 'undefined') {
    tempLink.setAttribute('target', '_blank');
  }
  document.body.appendChild(tempLink);
  tempLink.click();
  document.body.removeChild(tempLink);
  setTimeout(() => {
    // For Firefox it is necessary to delay revoking the ObjectURL
    window.URL.revokeObjectURL(blobURL);
  }, 100);
}

function getBase64(file) {
  console.log('getBase64', file)
  return new Promise((resolve, reject) => {
    console.log('getBase64.Promise', file)
    const reader = new FileReader();
    reader.readAsDataURL(file);
    reader.onload = () => resolve(reader.result);
    reader.onerror = error => reject(error);
  });
}

function fromBase64(base64) {
    const byteCharacters = atob(base64);
    const byteNumbers = new Array(byteCharacters.length);
    for (let i = 0; i < byteCharacters.length; i++) {
      byteNumbers[i] = byteCharacters.charCodeAt(i);
    }
    const byteArray = new Uint8Array(byteNumbers);
    return byteArray;
  }
</script>

<script>
app = Vue.createApp({
  data() {
    return {
      pdf: {
        page: 0,
        name:  'sample.pdf',
        src: 'data:application/pdf;base64,a4d94b9d56a7===',
        max_page: 0,
      },
      image: {
        src: '',
        mime: '',
        width: 0,
        height: 0
      },
      coordinates: {
				width: 0,
				height: 0,
				left: 0,
				top: 0,
			},
    }
  },
  methods: {
    change({coordinates, canvas}) {
      console.log(coordinates, canvas)
      this.coordinates = coordinates
    },
    crop() {
			// const { coordinates, canvas, } = this.$refs.cropper.getResult();
			// this.coordinates = coordinates;

			// You able to do different manipulations at a canvas
			// but there we just get a cropped image, that can be used
			// as src for <img/> to preview result
			// this.image = canvas.toDataURL();
			// upload
      const result = this.$refs.cropper.getResult();
      console.log(result);
      const self = this;
      const {
	      coordinates, image
      } = result;
      // const form = new FormData();
      // form.append('coordinates', this.coordinates);
      fetch('/crop', {
						method: 'POST',
						body: JSON.stringify({
              coordinates,
              image: {width: image.width, height: image.height },
              pdf: { base64: self.pdf.src, page: self.pdf.page }}),
						// body: form,
      }).then(function(response) {
        console.log(response);
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        return response;
      }).then(function(response) {
        console.log('2');
         return response.json();
         /* {
          "filename": "foobar.pdf",
          "base64": "a4f5fe3290f===",
        } */
      }).then(function(data) {
        console.log('3');
        console.log(data);
        const byteArray = fromBase64(data.base64);
        // const blob = new Blob([byteArray], {type: contentType});
        // let objectURL = URL.createObjectURL(blob);
        // myImage.src = objectURL;
        downloadFile(byteArray, self.pdf.name, 'application/pdf');
      });
		},
    loadPreviewOfPdf: function () {
      const self = this;
      const payload = {pdf: {page: self.pdf.page, base64: self.pdf.src}};
      console.log(payload);
      // send `POST` request
      fetch('/preview', {
        method: 'POST',
        body: JSON.stringify(payload),
      })
        .then(function (response) {
          console.log('>1');
          console.log(response);
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          return response;
        })
        .then(function (response) {
          console.log('>2');
          return response.json();
          /* {
           "mime": "image/png",
           "base64": "a4f5fe3290f===",
           "page": 0,
           "pages": 2,
         } */
        })
        .then(function (data) {
          console.log('>3');
          self.image.src = `data:${data.mime};base64,${data.base64}`
          console.log('>4');
          self.pdf.max_page = data.pages - 1;
          self.pdf.page = data.page;
          console.log('>5');
        })
        .catch(err => console.error(err));
    }, loadPDF(event) {
			// Reference to the DOM input element
			const { files } = event.target;
			console.log(1)
			// Ensure that you have a file before attempting to read it
			if (files && files[0]) {
        // 1. Revoke the object URL, to allow the garbage collector to destroy the uploaded before file
        if (this.image.src) {
          URL.revokeObjectURL(this.image.src)
        }
        const file = files[0];

        // base64 encode it
        const self = this;
        getBase64(file).then(function (data) {
          console.log('>0')
          self.pdf.src = data;
          self.pdf.name = file.name;
          self.loadPreviewOfPdf();
        });
      }
		},
  },
  components: {
  	Cropper: VueAdvancedCropper.Cropper
  }
}).mount('#app')
</script>
